# -*- coding: utf-8 -*-
"""Crypto-MachineLearningProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IBz1Zp0NsbDuLsKXVBj4DkoQc98wVyfr
"""

!pip install pandas numpy matplotlib statsmodels scipy seaborn yfinance pmdarima

#@title Library
import pandas as pd  # For data manipulation
import numpy as np  # For numerical operations
import matplotlib.pyplot as plt  # For data visualization
import seaborn as sns  # For enhanced plots
import statsmodels.api as sm  # For ARIMA and statistical tests
from statsmodels.tsa.stattools import adfuller  # Augmented Dickey-Fuller test for stationarity
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf  # ACF/PACF plots
from statsmodels.tsa.arima.model import ARIMA  # ARIMA model
from scipy.stats import zscore  # For data normalization if needed
import yfinance as yf  # To fetch cryptocurrency data
import pmdarima as pm  # Auto ARIMA for model selection
from sklearn.metrics import mean_squared_error  # RMSE for model evaluation

#@title File Loader
file_path = "ethereum_data.csv"
df = pd.read_csv(file_path, skiprows=2)  # Skip both rows
df.columns = ['date', 'close', 'high', 'low', 'open', 'volume']
print(df.head())

df.head()

df.info()

#@title Price Plot
# Convert the 'date' column to datetime objects if it's not already
df['date'] = pd.to_datetime(df['date'])

# Set the 'date' column as the index
df = df.set_index('date')

# Plot the time series
plt.figure(figsize=(12, 6))
sns.lineplot(data=df2['close'])  # Plotting the 'close' price
plt.title('Ethereum Close Price Time Series')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.grid(True)
plt.show()

df.head()

df.shape

#@title checking null
# Check for missing values
print(df.isnull().sum())

# Check data types of each column
print(df.dtypes)

# Statistical summary of numerical columns
print(df.describe())

# --- Feature Engineering ---

# Calculate daily percentage change (Price)
df['Daily_Pct_Change_Price'] = df['close'].pct_change()

# Calculate daily percentage change (Volume)
df['Daily_Pct_Change_Volume'] = df['volume'].pct_change()

# Calculate 7-day rolling percentage change (Price)
df['Rolling_7D_Pct_Change_Price'] = (df['Daily_Pct_Change_Price'] + 1).rolling(window=7).apply(lambda x: x.prod()) - 1


# Calculate 7-day rolling percentage change (Volume)
df['Rolling_7D_Pct_Change_Volume'] = (df['Daily_Pct_Change_Volume'] + 1).rolling(window=7).apply(lambda x: x.prod()) - 1

# Handle the initial NaNs created by pct_change and rolling
#df.fillna(method='bfill', inplace=True) # Backfill for the first few rows.
#check for infinity
print(df.isnull().sum())


print(df.head(10)) #show first 10

df.tail(7)

# Calculate daily percentage change (Price)
df['daily_pct_change_price'] = df['close'].pct_change()

# Calculate daily percentage change (Volume)
df['daily_pct_change_volume'] = df['volume'].pct_change()

# Calculate 7-day rolling percentage change (Price)
df['rolling_7d_pct_change_price'] = (df['daily_pct_change_price'] + 1).rolling(window=7).apply(lambda x: x.prod()) - 1

# Calculate 7-day rolling percentage change (Volume)
df['rolling_7d_pct_change_volume'] = (df['daily_pct_change_volume'] + 1).rolling(window=7).apply(lambda x: x.prod()) - 1

# Handle the initial NaNs created by pct_change and rolling
df.fillna(method='bfill', inplace=True) # Backfill for the first few rows.
#check for infinity
print(df.isnull().sum())

print(df.head(10)) #show first 10

# --- Model Building (ARIMA with pmdarima) ---

# Split data into training and testing sets (80/20 split)
train_data = df[:-int(len(df)*0.5)]
test_data = df[-int(len(df)*0.5):]

# Use pmdarima to automatically find the best ARIMA parameters
# We'll use the 'close' price for the auto_arima model fitting
auto_arima_model = pm.auto_arima(train_data['close'],
                                  start_p=0, start_q=0,
                                  test='adf',       # Use adftest to find optimal 'd'
                                  max_p=5, max_q=5, # Maximum p and q
                                  m=1,              # Frequency of time series (1 for daily)
                                  d=None,           # Let model determine 'd'
                                  seasonal=False,   # No seasonality
                                  start_P=0,
                                  D=0,
                                  trace=True,
                                  error_action='ignore',
                                  suppress_warnings=True,
                                  stepwise=True)

print(auto_arima_model.summary())

# Fit the best model
best_model = ARIMA(train_data['close'], order=auto_arima_model.order)
best_model_fit = best_model.fit()

# --- Prediction and Evaluation ---

# Make predictions on the test set
predictions = best_model_fit.predict(start=len(train_data), end=len(df)-1)

# Calculate RMSE
rmse = np.sqrt(mean_squared_error(test_data['close'], predictions))
print(f'RMSE: {rmse}')

# Visualize predictions against actual values
plt.figure(figsize=(12, 6))
plt.plot(test_data['close'], label='Actual')
plt.plot(predictions, label='Predictions')
plt.title('Ethereum Closing Price: Actual vs. Predicted')
plt.xlabel('Date')
plt.ylabel('Closing Price')
plt.legend()
plt.show()